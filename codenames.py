#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Mar 23 14:47:49 2018

@author: hae


To-do:
    * Multiple word handling
    * Target number of words as argument?

"""

common = ['before','upon','went','between','may','i','I','is','was','has','had','are','must','during','were','itself','does','through','based','the','be','to','of','and','a','in','that','have','I','it','for','not','on','with','he','as','you','do','at','this','but','his','by','from','they','we','say','her','she','or','an','will','my','one','all','would','there','their','what','so','up','out','if','about','who','get','which','go','me','when','make','can','like','time','no','just','him','know','take','people','into','year','your','good','some','could','them','see','other','than','then','now','look','only','come','its','over','think','also','back','after','use','two','how','our','work','first','well','way','even','new','want','because','any','these','give','day','most','us']

from datamuse import datamuse
import string

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Datamuse API
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

api = datamuse.Datamuse()
api.set_max_default(1000)

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# The following functions turn Datamuse API data into a dictionary.
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

def jja(word):
    '''
    Assume word is a text string.
    Return dictionary of nouns associated with the word in adjectival form.
    '''
    data = api.words(rel_jja=word)
    jjaDict = {}
    for num in range(len(data)):
        key = data[num]['word']
        value = data[num]['score']
        jjaDict[key] = value
    return(jjaDict)

def jjb(word):
    '''
    Assume word is a text string.
    Return dictionary of adjectives used to describe the word.
    '''
    data = api.words(rel_jjb=word)
    jjbDict = {}
    for num in range(len(data)):
        key = data[num]['word']
        value = data[num]['score']
        jjbDict[key] = value
    return(jjbDict)

def trg(word):
    '''
    Assume word is a text string.
    Return dictionary of words that are strongly associated with the word.
    '''
    data = api.words(rel_trg=word)
    trgDict = {}
    for num in range(len(data)):
        key = data[num]['word']
        value = data[num]['score']
        trgDict[key] = value
    return(trgDict)

def ml(word):
    '''
    Assume word is a text string.
    Return dictionary of terms with similar meanings to the word.
    '''
    data = api.words(ml=word)
    mlDict = {}
    for num in range(len(data)):
        key = data[num]['word']
        value = data[num]['score']
        mlDict[key] = value
    return(mlDict)

def lc(word):
    '''
    Assume word is a text string.
    Return dictionary of terms often follow the word in sentences.
    '''
    data = api.words(lc=word)
    lcDict = {}
    for num in range(len(data)):
        key = data[num]['word']
        value = data[num]['score']
        lcDict[key] = value
    return(lcDict)

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Combine the dictionaries generated by all five functions.
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

def allDicts(word):
    '''
    Assume word is a text string.
    Return a single dictionary of all related terms and their scores.
    '''
#    allDictsList = [jja(word),jjb(word),trg(word),ml(word),lc(word)]
#    allDictsList = [jja(word),trg(word),ml(word),lc(word)]
    allDictsList = [jja(word),jjb(word),trg(word),lc(word)]
    allDicts = {}
    for dictionaries in range(len(allDictsList)):
        for entry in allDictsList[dictionaries]:
            if ' ' not in entry:
                if entry in allDicts:
                    allDicts[entry] += allDictsList[dictionaries][entry]
                else:
                    allDicts[entry] = allDictsList[dictionaries][entry]
            else:
                pass
    return allDicts

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Figure out which words are in common.
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

def overlapDict(wordList):
    '''
    Assume wordList is a list of text strings.
    Return dictionary of common terms and scores among the words in wordList.
    '''
    # Create a list where each element is a dictionary of terms and scores for
    # all words.
    dictList = []
    for word in wordList:
        dictList.append(allDicts(word))
        
    # Create a dictionary of terms that are present in the dictionaries of all
    # words being considered.
    overlapDict = {}
    for element in range(len(dictList)-1):
        if element == 0:
            for entry in dictList[element]:
                if entry in dictList[element+1]:
                    overlapDict[entry] = dictList[element][entry] + dictList[element+1][entry]
                else:
                    pass
        else:
            for entry in dictList[element+1]:
                if entry in overlapDict:
                    overlapDict[entry] += dictList[element+1][entry]
                else:
                    pass
    overlapDict = deleteCommonWordsAndPunctuation(overlapDict)
    overlapDict = makeList(overlapDict)
    return overlapDict

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
# Make dictionaries more useful by deleting punctuation and sorting.
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

def deleteCommonWordsAndPunctuation(D):
    for word in common:
        if word in D.keys():
            del D[word]
    for mark in string.punctuation:
        if mark in D.keys():
            del D[mark]
    return D
    
def makeList(D):
    '''
    Assume D is a dictionary.
    Return it as a list of tuples of key-value pairs.
    '''
    goodList = list(D.items())
    goodList = sorted(goodList, key = lambda x: (-x[1],x[0]))
    return goodList

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Inputs and such
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

#L = ['ninja','green']
#print(overlapDict(L))

















